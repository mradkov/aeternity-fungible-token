contract FungibleToken =

  type balance = map(address, int)

  // allowance from account, for account, with amount
  type allowance = map((address, address), int)

  record state =
    { owner        : address
    , name         : string
    , symbol       : string
    , total_supply : int
    , decimals     : int
    , balances     : balance
    , allowances   : allowance }

  // add more events, e.g. burn
  datatype event =
    Transfer(indexed address, indexed address, indexed int)
    | Approval(indexed address, indexed address, indexed int)

  public stateful function init(name: string, total_supply : int, decimals : int, symbol : string) =
    { owner        = Call.caller,
      name         = name,
      symbol       = symbol,
      total_supply = total_supply,
      decimals     = decimals,
      balances     = {},
      allowances   = {} }


  // combine name, symbol and decimals in meta record
  public function name() : string =
    state.name

  public function symbol() : string =
    state.symbol

  public function decimals() : int =
    state.decimals

  public stateful function transfer(to: address, value: int) =
    internal_transfer(Call.caller, to, value)
    Chain.event(Transfer(Call.caller, to, value))

  public stateful function approve(spender: address, value: int) =
    // use generic error messages e.g. INVALID_VALUE_SUB_ZERO for better programatical checks
    require(value >= 0, "The provided value cannot be sub zero.")
    // add helper for allowance tuple or refactor allowance key to record
    put(state{ allowances[(Call.caller, spender)] = value })
    Chain.event(Approval(Call.caller, spender, state.allowances[(Call.caller, spender)]))

  public function total_supply() : int =
    state.total_supply

  // don't lookup defaults but fail if account not existing
  public function balance_of(owner: address) : int =
    Map.lookup_default(owner, state.balances, 0)

  public function allowance(owner: address, spender: address) : int =
    Map.lookup_default((owner, spender), state.allowances, 0)

  public function allowance_from(addr: address) : int =
    Map.lookup_default((addr, Call.caller), state.allowances, 0)

  // TODO check negative allowances possible
  public stateful function transfer_from(from: address, to: address, value: int) =
    require(allowance_from(from) >= value, "The provided value is larger than what is allowances.")
    // extract calculations froms state updates
    put(state{ allowances[(from, Call.caller)] = allowance_from(from) - value })
    internal_transfer(from, to, value)
    Chain.event(Transfer(from, to, value))

  // TODO check failure if allowance doesn't exist yet
  public stateful function increase_allowance(spender: address, added_value: int) =
    put(state{ allowances[(Call.caller, spender)] = state.allowances[(Call.caller, spender)] + added_value })
    Chain.event(Approval(Call.caller, spender, state.allowances[(Call.caller, spender)]))

  // TODO check failure if allowance doesn't exist yet
  public stateful function decrease_allowance(spender: address, subtracted_value: int) =
    put(state{ allowances[(Call.caller, spender)] = state.allowances[(Call.caller, spender)] - subtracted_value })
    Chain.event(Approval(Call.caller, spender, state.allowances[(Call.caller, spender)]))

  public stateful function mint(account: address, value: int) =
    only_owner()
    put(state{ total_supply = state.total_supply + value, balances[account] = balance_of(account) + value })

  // TODO check can burn negative, thus generate tokens?
  public stateful function burn(value: int) =
    require(balance_of(Call.caller) >= value, "The value provided for burning is less than account's balance.")
    put(state{ total_supply = state.total_supply - value, balances[Call.caller] = balance_of(Call.caller) - value })

  // INTERNAL FUNCTIONS

  // refactor all require calls in functions
  private function only_owner() =
    require(Call.caller == state.owner, "Only owner can mint new tokens!")

  private stateful function internal_transfer(from: address, to: address, value: int) =
    require(value >= 0, "The provided value cannot be sub zero")
    require(value < balance_of(from), "Not enough balance.")
    put(state{ balances[from] = balance_of(from) - value, balances[to] = balance_of(to) + value })

  // GENERIC HELPER FUNCTIONS

  private function require(expression : bool, error : string) =
    if(!expression)
      abort(error)
